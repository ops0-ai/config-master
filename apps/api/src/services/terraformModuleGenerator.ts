interface DiscoveryResource {
  id: string;
  resourceType: string;
  resourceId: string;
  name: string;
  region: string;
  provider: string;
  tags: Record<string, string>;
  metadata: any;
}

interface TerraformModule {
  name: string;
  path: string;
  content: string;
}

interface TerraformProject {
  files: Record<string, string>; // filename -> content
  structure: {
    main: string;
    variables: string;
    outputs: string;
    modules: Record<string, TerraformModule>;
    terraform: string;
    readme: string;
  };
}

export class TerraformModuleGenerator {
  
  /**
   * Generate a complete modular Terraform project structure
   */
  generateModularProject(resources: DiscoveryResource[], projectName: string = 'infrastructure'): TerraformProject {
    console.log(`üèóÔ∏è Generating modular Terraform project with ${resources.length} resources`);

    // Group resources by type and region
    const resourcesByType = this.groupResourcesByType(resources);
    const resourcesByRegion = this.groupResourcesByRegion(resources);
    
    const project: TerraformProject = {
      files: {},
      structure: {
        main: '',
        variables: '',
        outputs: '',
        modules: {},
        terraform: '',
        readme: ''
      }
    };

    // Generate main terraform configuration
    project.structure.terraform = this.generateTerraformConfig();
    project.files['terraform.tf'] = project.structure.terraform;

    // Generate main.tf with module calls
    project.structure.main = this.generateMainTf(resourcesByType, resourcesByRegion);
    project.files['main.tf'] = project.structure.main;

    // Generate variables.tf
    project.structure.variables = this.generateVariablesTf(resourcesByRegion);
    project.files['variables.tf'] = project.structure.variables;

    // Generate outputs.tf
    project.structure.outputs = this.generateOutputsTf(resourcesByType);
    project.files['outputs.tf'] = project.structure.outputs;

    // Generate individual modules for each resource type
    for (const [resourceType, resourceList] of Object.entries(resourcesByType)) {
      const moduleName = this.getModuleName(resourceType);
      const module = this.generateResourceModule(resourceType, resourceList, moduleName);
      
      project.structure.modules[moduleName] = module;
      
      // Add module files to the project
      project.files[`modules/${module.path}/main.tf`] = module.content;
      project.files[`modules/${module.path}/variables.tf`] = this.generateModuleVariables(resourceType, resourceList);
      project.files[`modules/${module.path}/outputs.tf`] = this.generateModuleOutputs(resourceType, resourceList);
    }

    // Generate README
    project.structure.readme = this.generateReadme(projectName, resourcesByType, resourcesByRegion);
    project.files['README.md'] = project.structure.readme;

    // Generate environment-specific tfvars
    project.files['terraform.tfvars.example'] = this.generateTfvarsExample(resourcesByRegion);
    project.files['dev.tfvars'] = this.generateEnvironmentTfvars('dev', resourcesByRegion);
    project.files['prod.tfvars'] = this.generateEnvironmentTfvars('prod', resourcesByRegion);

    // Generate terraform state file
    project.files['terraform.tfstate'] = this.generateTerraformState(resources, projectName);

    console.log(`‚úÖ Generated modular project with ${Object.keys(project.files).length} files`);
    return project;
  }

  /**
   * Group resources by type
   */
  private groupResourcesByType(resources: DiscoveryResource[]): Record<string, DiscoveryResource[]> {
    return resources.reduce((acc, resource) => {
      const type = resource.resourceType;
      if (!acc[type]) acc[type] = [];
      acc[type].push(resource);
      return acc;
    }, {} as Record<string, DiscoveryResource[]>);
  }

  /**
   * Group resources by region
   */
  private groupResourcesByRegion(resources: DiscoveryResource[]): Record<string, DiscoveryResource[]> {
    return resources.reduce((acc, resource) => {
      const region = resource.region;
      if (!acc[region]) acc[region] = [];
      acc[region].push(resource);
      return acc;
    }, {} as Record<string, DiscoveryResource[]>);
  }

  /**
   * Generate terraform.tf with providers and backend configuration
   */
  private generateTerraformConfig(): string {
    return `# Terraform configuration
# Generated by Pulse Infrastructure Discovery

terraform {
  required_version = ">= 1.5"
  
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
    random = {
      source  = "hashicorp/random"
      version = "~> 3.1"
    }
  }

  # Uncomment and configure for remote state
  # backend "s3" {
  #   bucket         = "your-terraform-state-bucket"
  #   key            = "infrastructure/terraform.tfstate"
  #   region         = "us-east-1"
  #   encrypt        = true
  #   dynamodb_table = "your-terraform-state-lock"
  # }
}

# Default provider configuration
provider "aws" {
  region = var.aws_region

  default_tags {
    tags = var.common_tags
  }
}

# Additional provider for cross-region resources
provider "aws" {
  alias  = "us_east_1"
  region = "us-east-1"

  default_tags {
    tags = var.common_tags
  }
}`;
  }

  /**
   * Generate main.tf with module calls
   */
  private generateMainTf(resourcesByType: Record<string, DiscoveryResource[]>, resourcesByRegion: Record<string, DiscoveryResource[]>): string {
    let content = `# Main infrastructure configuration
# Generated by Pulse Infrastructure Discovery

locals {
  environment = var.environment
  project     = var.project_name
  
  # Common tags applied to all resources
  common_tags = merge(var.common_tags, {
    Environment   = local.environment
    Project       = local.project
    ManagedBy     = "terraform"
    GeneratedBy   = "pulse-discovery"
    GeneratedAt   = "${new Date().toISOString()}"
  })
}

`;

    // Generate module calls for each resource type
    for (const [resourceType, resources] of Object.entries(resourcesByType)) {
      const moduleName = this.getModuleName(resourceType);
      const regions = [...new Set(resources.map(r => r.region))];
      
      content += `# ${this.getResourceTypeLabel(resourceType)} Module
module "${moduleName}" {
  source = "./modules/${moduleName}"
  
  # Environment configuration
  environment    = local.environment
  project_name   = local.project
  aws_region     = var.aws_region
  
  # Resource configuration
  regions        = ${JSON.stringify(regions)}
  
  # Tagging
  common_tags    = local.common_tags
  
  # Resource-specific variables
${this.generateModuleVariables(resourceType, resources, '  ')}
}

`;
    }

    return content;
  }

  /**
   * Generate variables.tf
   */
  private generateVariablesTf(resourcesByRegion: Record<string, DiscoveryResource[]>): string {
    const regions = Object.keys(resourcesByRegion);
    const primaryRegion = regions[0] || 'us-east-1';

    return `# Variables configuration
# Generated by Pulse Infrastructure Discovery

variable "aws_region" {
  description = "Primary AWS region for resources"
  type        = string
  default     = "${primaryRegion}"
}

variable "environment" {
  description = "Environment name (dev, staging, prod)"
  type        = string
  default     = "dev"
  
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be one of: dev, staging, prod."
  }
}

variable "project_name" {
  description = "Name of the project"
  type        = string
  default     = "pulse-discovered-infrastructure"
}

variable "common_tags" {
  description = "Common tags to apply to all resources"
  type        = map(string)
  default = {
    Owner       = "infrastructure-team"
    Source      = "pulse-discovery"
    CostCenter  = "engineering"
  }
}

variable "allowed_regions" {
  description = "List of allowed AWS regions"
  type        = list(string)
  default     = ${JSON.stringify(regions, null, 4)}
}

# Environment-specific variables
variable "enable_monitoring" {
  description = "Enable CloudWatch monitoring"
  type        = bool
  default     = true
}

variable "enable_backup" {
  description = "Enable automated backups where applicable"
  type        = bool
  default     = true
}

variable "backup_retention_days" {
  description = "Number of days to retain backups"
  type        = number
  default     = 30
}`;
  }

  /**
   * Generate outputs.tf
   */
  private generateOutputsTf(resourcesByType: Record<string, DiscoveryResource[]>): string {
    let content = `# Outputs configuration
# Generated by Pulse Infrastructure Discovery

output "infrastructure_summary" {
  description = "Summary of discovered infrastructure"
  value = {
    total_resources = ${Object.values(resourcesByType).flat().length}
    resource_types  = [${Object.keys(resourcesByType).map(type => `"${type}"`).join(', ')}]
    regions        = distinct([${Object.values(resourcesByType).flat().map(r => `"${r.region}"`).join(', ')}])
  }
}

`;

    // Generate outputs for each module
    for (const resourceType of Object.keys(resourcesByType)) {
      const moduleName = this.getModuleName(resourceType);
      const label = this.getResourceTypeLabel(resourceType);

      content += `output "${moduleName}_resources" {
  description = "${label} resources information"
  value       = module.${moduleName}
}

`;
    }

    return content;
  }

  /**
   * Generate a resource-specific module
   */
  private generateResourceModule(resourceType: string, resources: DiscoveryResource[], moduleName: string): TerraformModule {
    let content = `# ${this.getResourceTypeLabel(resourceType)} Module
# Generated by Pulse Infrastructure Discovery

`;

    content += this.generateResourceTypeConfig(resourceType, resources);

    return {
      name: moduleName,
      path: moduleName,
      content
    };
  }

  /**
   * Generate Terraform configuration for specific resource type
   */
  private generateResourceTypeConfig(resourceType: string, resources: DiscoveryResource[]): string {
    switch (resourceType) {
      case 'aws::ec2::instance':
        return this.generateEC2Module(resources);
      case 'aws::ec2::vpc':
        return this.generateVPCModule(resources);
      case 'aws::ec2::subnet':
        return this.generateSubnetModule(resources);
      case 'aws::ec2::security-group':
        return this.generateSecurityGroupModule(resources);
      case 'aws::s3::bucket':
        return this.generateS3Module(resources);
      case 'aws::rds::instance':
        return this.generateRDSModule(resources);
      case 'aws::lambda::function':
        return this.generateLambdaModule(resources);
      case 'aws::iam::role':
        return this.generateIAMModule(resources);
      case 'aws::elb::load-balancer':
        return this.generateELBModule(resources);
      default:
        return this.generateGenericModule(resourceType, resources);
    }
  }

  /**
   * Generate EC2 module
   */
  private generateEC2Module(resources: DiscoveryResource[]): string {
    let content = `# EC2 Instances Configuration

locals {
  ec2_instances = {
${resources.map(resource => {
  const name = this.sanitizeName(resource.name);
  return `    "${name}" = {
      instance_id   = "${resource.resourceId}"
      instance_type = "${resource.metadata.instanceType || 't3.micro'}"
      ami_id        = "${resource.metadata.imageId || 'ami-placeholder'}"
      key_name      = "${resource.metadata.keyName || ''}"
      subnet_id     = "${resource.metadata.subnetId || ''}"
      vpc_id        = "${resource.metadata.vpcId || ''}"
      region        = "${resource.region}"
      tags = ${JSON.stringify(resource.tags, null, 8)}
    }`;
}).join(',\n')}
  }
}

# Import existing EC2 instances
resource "aws_instance" "imported" {
  for_each = local.ec2_instances

  # Import configuration - these values should match existing resources
  ami           = each.value.ami_id
  instance_type = each.value.instance_type
  key_name      = each.value.key_name != "" ? each.value.key_name : null
  subnet_id     = each.value.subnet_id != "" ? each.value.subnet_id : null

  tags = merge(var.common_tags, each.value.tags, {
    Name = each.key
  })

  lifecycle {
    # Prevent accidental instance replacement
    ignore_changes = [ami, user_data, user_data_base64]
  }
}

# Data sources for reference
data "aws_instance" "existing" {
  for_each = local.ec2_instances
  
  instance_id = each.value.instance_id
}`;

    return content;
  }

  /**
   * Generate VPC module
   */
  private generateVPCModule(resources: DiscoveryResource[]): string {
    return `# VPC Configuration

locals {
  vpcs = {
${resources.map(resource => {
  const name = this.sanitizeName(resource.name);
  return `    "${name}" = {
      vpc_id                = "${resource.resourceId}"
      cidr_block           = "${resource.metadata.cidrBlock || '10.0.0.0/16'}"
      enable_dns_hostnames = true
      enable_dns_support   = true
      region               = "${resource.region}"
      tags = ${JSON.stringify(resource.tags, null, 8)}
    }`;
}).join(',\n')}
  }
}

# Import existing VPCs
resource "aws_vpc" "imported" {
  for_each = local.vpcs

  cidr_block           = each.value.cidr_block
  enable_dns_hostnames = each.value.enable_dns_hostnames
  enable_dns_support   = each.value.enable_dns_support

  tags = merge(var.common_tags, each.value.tags, {
    Name = each.key
  })
}`;
  }

  /**
   * Generate S3 module
   */
  private generateS3Module(resources: DiscoveryResource[]): string {
    return `# S3 Buckets Configuration

locals {
  s3_buckets = {
${resources.map(resource => {
  const name = this.sanitizeName(resource.name);
  return `    "${name}" = {
      bucket_name = "${resource.resourceId}"
      region      = "${resource.region}"
      tags = ${JSON.stringify(resource.tags, null, 8)}
    }`;
}).join(',\n')}
  }
}

# Import existing S3 buckets
resource "aws_s3_bucket" "imported" {
  for_each = local.s3_buckets

  bucket = each.value.bucket_name

  tags = merge(var.common_tags, each.value.tags)
}

# S3 bucket versioning
resource "aws_s3_bucket_versioning" "imported" {
  for_each = local.s3_buckets
  
  bucket = aws_s3_bucket.imported[each.key].id
  versioning_configuration {
    status = "Enabled"
  }
}

# S3 bucket server-side encryption
resource "aws_s3_bucket_server_side_encryption_configuration" "imported" {
  for_each = local.s3_buckets

  bucket = aws_s3_bucket.imported[each.key].id

  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}`;
  }

  /**
   * Generate RDS module
   */
  private generateRDSModule(resources: DiscoveryResource[]): string {
    return `# RDS Instances Configuration

locals {
  rds_instances = {
${resources.map(resource => {
  const name = this.sanitizeName(resource.name);
  return `    "${name}" = {
      identifier       = "${resource.resourceId}"
      engine          = "${resource.metadata.engine || 'mysql'}"
      engine_version  = "${resource.metadata.engineVersion || '8.0'}"
      instance_class  = "${resource.metadata.dbInstanceClass || 'db.t3.micro'}"
      allocated_storage = ${resource.metadata.allocatedStorage || 20}
      region          = "${resource.region}"
      tags = ${JSON.stringify(resource.tags, null, 8)}
    }`;
}).join(',\n')}
  }
}

# Import existing RDS instances
resource "aws_db_instance" "imported" {
  for_each = local.rds_instances

  identifier     = each.value.identifier
  engine         = each.value.engine
  engine_version = each.value.engine_version
  instance_class = each.value.instance_class
  allocated_storage = each.value.allocated_storage
  
  # These must be provided for import
  db_name  = var.db_name
  username = var.db_username
  password = var.db_password
  
  skip_final_snapshot = true

  tags = merge(var.common_tags, each.value.tags)

  lifecycle {
    ignore_changes = [password]
  }
}`;
  }

  /**
   * Generate Lambda module
   */
  private generateLambdaModule(resources: DiscoveryResource[]): string {
    return `# Lambda Functions Configuration

locals {
  lambda_functions = {
${resources.map(resource => {
  const name = this.sanitizeName(resource.name);
  return `    "${name}" = {
      function_name = "${resource.resourceId}"
      runtime       = "${resource.metadata.runtime || 'nodejs18.x'}"
      handler       = "${resource.metadata.handler || 'index.handler'}"
      timeout       = ${resource.metadata.timeout || 3}
      memory_size   = ${resource.metadata.memorySize || 128}
      role_arn      = "${resource.metadata.role || ''}"
      region        = "${resource.region}"
      tags = ${JSON.stringify(resource.tags, null, 8)}
    }`;
}).join(',\n')}
  }
}

# Import existing Lambda functions
resource "aws_lambda_function" "imported" {
  for_each = local.lambda_functions

  function_name = each.value.function_name
  role          = each.value.role_arn
  handler       = each.value.handler
  runtime       = each.value.runtime
  timeout       = each.value.timeout
  memory_size   = each.value.memory_size
  
  # Placeholder code - replace with actual function code
  filename         = "\${path.module}/lambda-placeholder.zip"
  source_code_hash = data.archive_file.lambda_placeholder[each.key].output_base64sha256

  tags = merge(var.common_tags, each.value.tags)

  lifecycle {
    ignore_changes = [filename, source_code_hash]
  }
}

# Placeholder lambda code
data "archive_file" "lambda_placeholder" {
  for_each = local.lambda_functions
  
  type        = "zip"
  output_path = "\${path.module}/lambda-\${each.key}-placeholder.zip"
  
  source {
    content = jsonencode({
      message = "Placeholder function - replace with actual code"
    })
    filename = "index.js"
  }
}`;
  }

  /**
   * Generate generic module for unsupported resource types
   */
  private generateGenericModule(resourceType: string, resources: DiscoveryResource[]): string {
    return `# Generic configuration for ${resourceType}
# Note: This resource type requires manual configuration

locals {
  resources = {
${resources.map(resource => {
  const name = this.sanitizeName(resource.name);
  return `    "${name}" = {
      resource_id = "${resource.resourceId}"
      type        = "${resourceType}"
      region      = "${resource.region}"
      metadata    = ${JSON.stringify(resource.metadata, null, 8)}
      tags        = ${JSON.stringify(resource.tags, null, 8)}
    }`;
}).join(',\n')}
  }
}

# Manual configuration required for ${resourceType}
# Please refer to Terraform AWS provider documentation
# Resource IDs for import: ${resources.map(r => r.resourceId).join(', ')}`;
  }

  /**
   * Generate module variables
   */
  private generateModuleVariables(resourceType: string, resources: DiscoveryResource[], indent: string = ''): string {
    const baseVars = `${indent}variable "environment" {
${indent}  description = "Environment name"
${indent}  type        = string
${indent}}

${indent}variable "project_name" {
${indent}  description = "Project name"
${indent}  type        = string
${indent}}

${indent}variable "aws_region" {
${indent}  description = "AWS region"
${indent}  type        = string
${indent}}

${indent}variable "common_tags" {
${indent}  description = "Common tags for all resources"
${indent}  type        = map(string)
${indent}  default     = {}
${indent}}

${indent}variable "regions" {
${indent}  description = "List of regions containing resources"
${indent}  type        = list(string)
${indent}  default     = []
${indent}}`;

    // Add resource-specific variables
    let specificVars = '';
    
    if (resourceType === 'aws::rds::instance') {
      specificVars = `

${indent}variable "db_name" {
${indent}  description = "Database name"
${indent}  type        = string
${indent}  default     = "placeholder"
${indent}}

${indent}variable "db_username" {
${indent}  description = "Database username"
${indent}  type        = string
${indent}  default     = "admin"
${indent}  sensitive   = true
${indent}}

${indent}variable "db_password" {
${indent}  description = "Database password"
${indent}  type        = string
${indent}  default     = "change-me-please"
${indent}  sensitive   = true
${indent}}`;
    }

    return baseVars + specificVars;
  }

  /**
   * Generate module outputs
   */
  private generateModuleOutputs(resourceType: string, resources: DiscoveryResource[]): string {
    const resourceName = this.getModuleName(resourceType);
    
    return `# Module outputs for ${this.getResourceTypeLabel(resourceType)}

output "resource_count" {
  description = "Number of ${this.getResourceTypeLabel(resourceType).toLowerCase()} resources"
  value       = ${resources.length}
}

output "resource_ids" {
  description = "List of resource IDs"
  value       = [${resources.map(r => `"${r.resourceId}"`).join(', ')}]
}

output "resources_by_region" {
  description = "Resources grouped by region"
  value = {
${[...new Set(resources.map(r => r.region))].map(region => {
  const regionResources = resources.filter(r => r.region === region);
  return `    "${region}" = [${regionResources.map(r => `"${r.resourceId}"`).join(', ')}]`;
}).join(',\n')}
  }
}`;
  }

  /**
   * Generate project README
   */
  private generateReadme(projectName: string, resourcesByType: Record<string, DiscoveryResource[]>, resourcesByRegion: Record<string, DiscoveryResource[]>): string {
    const totalResources = Object.values(resourcesByType).flat().length;
    
    return `# ${projectName}

Infrastructure as Code project generated by **Pulse Infrastructure Discovery**.

## Overview

This Terraform project manages **${totalResources} resources** across **${Object.keys(resourcesByRegion).length} AWS region(s)**.

### Resource Summary

| Resource Type | Count |
|---------------|-------|
${Object.entries(resourcesByType).map(([type, resources]) => 
  `| ${this.getResourceTypeLabel(type)} | ${resources.length} |`
).join('\n')}

### Regions

- ${Object.keys(resourcesByRegion).join('\n- ')}

## Project Structure

\`\`\`
.
‚îú‚îÄ‚îÄ main.tf                     # Main configuration with module calls
‚îú‚îÄ‚îÄ variables.tf                # Global variables
‚îú‚îÄ‚îÄ outputs.tf                  # Global outputs
‚îú‚îÄ‚îÄ terraform.tf                # Provider and backend configuration
‚îú‚îÄ‚îÄ *.tfvars                    # Environment-specific variables
‚îî‚îÄ‚îÄ modules/                    # Resource-specific modules
${Object.keys(resourcesByType).map(type => {
  const moduleName = this.getModuleName(type);
  return `    ‚îú‚îÄ‚îÄ ${moduleName}/           # ${this.getResourceTypeLabel(type)} module
    ‚îÇ   ‚îú‚îÄ‚îÄ main.tf
    ‚îÇ   ‚îú‚îÄ‚îÄ variables.tf
    ‚îÇ   ‚îî‚îÄ‚îÄ outputs.tf`;
}).join('\n')}
\`\`\`

## Getting Started

### Prerequisites

- [Terraform](https://terraform.io/downloads) >= 1.5
- [AWS CLI](https://aws.amazon.com/cli/) configured with appropriate credentials
- Access to the AWS account containing the discovered resources

### Setup

1. **Clone or download this project**

2. **Configure your environment variables:**
   \`\`\`bash
   cp terraform.tfvars.example terraform.tfvars
   # Edit terraform.tfvars with your specific values
   \`\`\`

3. **Initialize Terraform:**
   \`\`\`bash
   terraform init
   \`\`\`

4. **Review the plan:**
   \`\`\`bash
   terraform plan
   \`\`\`

5. **Import existing resources:**
   \`\`\`bash
   # Import commands will be generated based on your resources
   # Example:
   ${Object.entries(resourcesByType).slice(0, 3).map(([type, resources]) => {
     const resource = resources[0];
     return `   # terraform import 'module.${this.getModuleName(type)}.${this.getTerraformResourceType(type)}.imported["${this.sanitizeName(resource.name)}"]' ${resource.resourceId}`;
   }).join('\n')}
   \`\`\`

6. **Apply the configuration:**
   \`\`\`bash
   terraform apply
   \`\`\`

## Environment Management

This project supports multiple environments:

- **dev.tfvars**: Development environment
- **prod.tfvars**: Production environment
- **terraform.tfvars.example**: Template for custom environments

Deploy to different environments:
\`\`\`bash
terraform plan -var-file="dev.tfvars"
terraform apply -var-file="prod.tfvars"
\`\`\`

## Module Documentation

${Object.entries(resourcesByType).map(([type, resources]) => {
  const moduleName = this.getModuleName(type);
  return `### ${this.getResourceTypeLabel(type)} Module (\`modules/${moduleName}\`)

Manages ${resources.length} ${this.getResourceTypeLabel(type).toLowerCase()} resource(s) across regions: ${[...new Set(resources.map(r => r.region))].join(', ')}.

**Resources:**
${resources.slice(0, 5).map(r => `- \`${r.resourceId}\` (${r.name})`).join('\n')}
${resources.length > 5 ? `- ... and ${resources.length - 5} more` : ''}`;
}).join('\n\n')}

## Important Notes

‚ö†Ô∏è **Before applying this configuration:**

1. **Review all resource configurations** carefully
2. **Update placeholder values** (passwords, sensitive data, etc.)
3. **Configure remote state backend** in \`terraform.tf\`
4. **Test in a non-production environment** first
5. **Import existing resources** before applying changes

## Generated Information

- **Generated by**: Pulse Infrastructure Discovery
- **Generated at**: ${new Date().toISOString()}
- **Total resources**: ${totalResources}
- **Regions**: ${Object.keys(resourcesByRegion).join(', ')}

## Support

For questions about this generated infrastructure code or Pulse Discovery features, please refer to your Pulse platform documentation.`;
  }

  /**
   * Generate terraform.tfvars.example
   */
  private generateTfvarsExample(resourcesByRegion: Record<string, DiscoveryResource[]>): string {
    const primaryRegion = Object.keys(resourcesByRegion)[0] || 'us-east-1';
    
    return `# Example Terraform variables
# Copy this file to terraform.tfvars and customize for your environment

# Basic configuration
aws_region   = "${primaryRegion}"
environment  = "dev"
project_name = "pulse-discovered-infrastructure"

# Common tags applied to all resources
common_tags = {
  Environment   = "dev"
  Project       = "infrastructure-discovery"
  Owner         = "infrastructure-team"
  CostCenter    = "engineering"
  ManagedBy     = "terraform"
  Source        = "pulse-discovery"
}

# Feature toggles
enable_monitoring = true
enable_backup    = true
backup_retention_days = 30

# Database credentials (for RDS resources)
# db_username = "admin"
# db_password = "your-secure-password"  # Consider using AWS Secrets Manager
# db_name     = "application"`;
  }

  /**
   * Generate environment-specific tfvars
   */
  private generateEnvironmentTfvars(environment: string, resourcesByRegion: Record<string, DiscoveryResource[]>): string {
    const primaryRegion = Object.keys(resourcesByRegion)[0] || 'us-east-1';
    
    const environmentConfigs = {
      dev: {
        enable_monitoring: true,
        enable_backup: false,
        backup_retention_days: 7
      },
      prod: {
        enable_monitoring: true,
        enable_backup: true,
        backup_retention_days: 30
      }
    };
    
    const config = environmentConfigs[environment as keyof typeof environmentConfigs] || environmentConfigs.dev;

    return `# ${environment.toUpperCase()} Environment Configuration

aws_region   = "${primaryRegion}"
environment  = "${environment}"
project_name = "pulse-discovered-infrastructure"

common_tags = {
  Environment   = "${environment}"
  Project       = "infrastructure-discovery"
  Owner         = "infrastructure-team"
  CostCenter    = "engineering"
  ManagedBy     = "terraform"
  Source        = "pulse-discovery"
}

# ${environment.toUpperCase()}-specific settings
enable_monitoring = ${config.enable_monitoring}
enable_backup = ${config.enable_backup}
backup_retention_days = ${config.backup_retention_days}`;
  }

  /**
   * Helper methods
   */
  private getModuleName(resourceType: string): string {
    const typeMap: Record<string, string> = {
      'aws::ec2::instance': 'ec2_instances',
      'aws::ec2::vpc': 'vpc',
      'aws::ec2::subnet': 'subnets',
      'aws::ec2::security-group': 'security_groups',
      'aws::s3::bucket': 's3_buckets',
      'aws::rds::instance': 'rds_instances',
      'aws::lambda::function': 'lambda_functions',
      'aws::iam::role': 'iam_roles',
      'aws::elb::load-balancer': 'load_balancers'
    };
    
    return typeMap[resourceType] || resourceType.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
  }

  private getResourceTypeLabel(resourceType: string): string {
    const labelMap: Record<string, string> = {
      'aws::ec2::instance': 'EC2 Instances',
      'aws::ec2::vpc': 'VPC',
      'aws::ec2::subnet': 'Subnets', 
      'aws::ec2::security-group': 'Security Groups',
      'aws::s3::bucket': 'S3 Buckets',
      'aws::rds::instance': 'RDS Instances',
      'aws::lambda::function': 'Lambda Functions',
      'aws::iam::role': 'IAM Roles',
      'aws::elb::load-balancer': 'Load Balancers'
    };
    
    return labelMap[resourceType] || resourceType;
  }

  private getTerraformResourceType(resourceType: string): string {
    const typeMap: Record<string, string> = {
      'aws::ec2::instance': 'aws_instance',
      'aws::ec2::vpc': 'aws_vpc',
      'aws::ec2::subnet': 'aws_subnet',
      'aws::ec2::security-group': 'aws_security_group',
      'aws::s3::bucket': 'aws_s3_bucket',
      'aws::rds::instance': 'aws_db_instance',
      'aws::lambda::function': 'aws_lambda_function',
      'aws::iam::role': 'aws_iam_role',
      'aws::elb::load-balancer': 'aws_lb'
    };
    
    return typeMap[resourceType] || 'aws_resource';
  }

  private sanitizeName(name: string): string {
    return name
      .replace(/[^a-zA-Z0-9_-]/g, '_')
      .replace(/^[0-9]/, 'resource_$&')
      .toLowerCase();
  }

  // Additional helper methods for specific resource configurations...
  private generateSecurityGroupModule(resources: DiscoveryResource[]): string {
    return `# Security Groups Configuration

locals {
  security_groups = {
${resources.map(resource => {
  const name = this.sanitizeName(resource.name);
  return `    "${name}" = {
      group_id    = "${resource.resourceId}"
      name        = "${resource.name}"
      description = "${resource.metadata.description || 'Imported security group'}"
      vpc_id      = "${resource.metadata.vpcId || ''}"
      region      = "${resource.region}"
      tags = ${JSON.stringify(resource.tags, null, 8)}
    }`;
}).join(',\n')}
  }
}

# Import existing Security Groups
resource "aws_security_group" "imported" {
  for_each = local.security_groups

  name        = each.value.name
  description = each.value.description
  vpc_id      = each.value.vpc_id != "" ? each.value.vpc_id : null

  tags = merge(var.common_tags, each.value.tags)
  
  lifecycle {
    # Rules will need to be managed separately
    ignore_changes = [ingress, egress]
  }
}`;
  }

  private generateSubnetModule(resources: DiscoveryResource[]): string {
    return `# Subnets Configuration

locals {
  subnets = {
${resources.map(resource => {
  const name = this.sanitizeName(resource.name);
  return `    "${name}" = {
      subnet_id               = "${resource.resourceId}"
      cidr_block              = "${resource.metadata.cidrBlock}"
      vpc_id                  = "${resource.metadata.vpcId}"
      availability_zone       = "${resource.metadata.availabilityZone}"
      map_public_ip_on_launch = ${resource.metadata.mapPublicIpOnLaunch || false}
      region                  = "${resource.region}"
      tags = ${JSON.stringify(resource.tags, null, 8)}
    }`;
}).join(',\n')}
  }
}

# Import existing Subnets
resource "aws_subnet" "imported" {
  for_each = local.subnets

  vpc_id                  = each.value.vpc_id
  cidr_block              = each.value.cidr_block
  availability_zone       = each.value.availability_zone
  map_public_ip_on_launch = each.value.map_public_ip_on_launch

  tags = merge(var.common_tags, each.value.tags, {
    Name = each.key
  })
}`;
  }

  private generateIAMModule(resources: DiscoveryResource[]): string {
    return `# IAM Roles Configuration

locals {
  iam_roles = {
${resources.map(resource => {
  const name = this.sanitizeName(resource.name);
  return `    "${name}" = {
      role_name = "${resource.resourceId}"
      path      = "${resource.metadata.path || '/'}"
      arn       = "${resource.metadata.arn}"
      region    = "${resource.region}"
      tags = ${JSON.stringify(resource.tags, null, 8)}
    }`;
}).join(',\n')}
  }
}

# Import existing IAM Roles
resource "aws_iam_role" "imported" {
  for_each = local.iam_roles

  name = each.value.role_name
  path = each.value.path
  
  # Default assume role policy - update as needed
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "ec2.amazonaws.com"
        }
      }
    ]
  })

  tags = merge(var.common_tags, each.value.tags)
  
  lifecycle {
    ignore_changes = [assume_role_policy]
  }
}`;
  }

  private generateELBModule(resources: DiscoveryResource[]): string {
    return `# Load Balancers Configuration

locals {
  load_balancers = {
${resources.map(resource => {
  const name = this.sanitizeName(resource.name);
  return `    "${name}" = {
      lb_name    = "${resource.name}"
      lb_type    = "${resource.metadata.type || 'application'}"
      scheme     = "${resource.metadata.scheme || 'internet-facing'}"
      vpc_id     = "${resource.metadata.vpcId || ''}"
      dns_name   = "${resource.metadata.dnsName || ''}"
      region     = "${resource.region}"
      tags = ${JSON.stringify(resource.tags, null, 8)}
    }`;
}).join(',\n')}
  }
}

# Import existing Load Balancers
resource "aws_lb" "imported" {
  for_each = local.load_balancers

  name               = each.value.lb_name
  load_balancer_type = each.value.lb_type
  scheme             = each.value.scheme
  
  # Subnets need to be specified - update with actual subnet IDs
  # subnets = var.subnet_ids

  tags = merge(var.common_tags, each.value.tags)
  
  lifecycle {
    ignore_changes = [subnets]
  }
}`;
  }

  /**
   * Generate terraform.tfstate file with discovered resources
   */
  private generateTerraformState(resources: DiscoveryResource[], projectName: string): string {
    const stateResources: any = {};
    
    // Generate state entries for each resource
    resources.forEach((resource, index) => {
      const resourceType = this.getTerraformResourceType(resource.resourceType);
      const resourceKey = `${resourceType}.${resource.name.replace(/[^a-zA-Z0-9_]/g, '_')}_${index}`;
      
      stateResources[resourceKey] = {
        mode: "managed",
        type: resourceType,
        name: `${resource.name.replace(/[^a-zA-Z0-9_]/g, '_')}_${index}`,
        provider: `provider["registry.terraform.io/hashicorp/aws"]`,
        instances: [
          {
            schema_version: 1,
            attributes: {
              id: resource.resourceId,
              arn: resource.metadata.arn || `arn:aws:${this.getServiceFromResourceType(resource.resourceType)}:${resource.region}::${resource.resourceId}`,
              name: resource.name,
              region: resource.region,
              tags: resource.tags,
              ...this.getResourceSpecificAttributes(resource)
            },
            sensitive_attributes: []
          }
        ]
      };
    });

    const stateFile = {
      version: 4,
      terraform_version: "1.5.0",
      serial: 1,
      lineage: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      outputs: {},
      resources: Object.values(stateResources),
      check_results: []
    };

    return JSON.stringify(stateFile, null, 2);
  }

  /**
   * Get resource-specific attributes for state file
   */
  private getResourceSpecificAttributes(resource: DiscoveryResource): any {
    const baseAttrs = {
      availability_zone: resource.metadata.availabilityZone || `${resource.region}a`,
      vpc_id: resource.metadata.vpcId || null,
      subnet_id: resource.metadata.subnetId || null,
    };

    switch (resource.resourceType) {
      case 'AWS::EC2::Instance':
        return {
          ...baseAttrs,
          instance_type: resource.metadata.instanceType || 't3.micro',
          ami: resource.metadata.imageId || 'ami-12345678',
          security_groups: resource.metadata.securityGroups || [],
          key_name: resource.metadata.keyName || null,
          private_ip: resource.metadata.privateIpAddress || null,
          public_ip: resource.metadata.publicIpAddress || null,
          instance_state: resource.metadata.state || 'running'
        };
      
      case 'AWS::RDS::DBInstance':
        return {
          ...baseAttrs,
          engine: resource.metadata.engine || 'mysql',
          engine_version: resource.metadata.engineVersion || '8.0',
          instance_class: resource.metadata.dbInstanceClass || 'db.t3.micro',
          allocated_storage: resource.metadata.allocatedStorage || 20,
          database_name: resource.metadata.dbName || 'app',
          username: resource.metadata.masterUsername || 'admin',
          port: resource.metadata.port || 3306,
          multi_az: resource.metadata.multiAZ || false,
          publicly_accessible: resource.metadata.publiclyAccessible || false
        };
      
      case 'AWS::S3::Bucket':
        return {
          bucket: resource.name,
          bucket_domain_name: `${resource.name}.s3.amazonaws.com`,
          bucket_regional_domain_name: `${resource.name}.s3.${resource.region}.amazonaws.com`,
          hosted_zone_id: this.getS3HostedZoneId(resource.region),
          versioning: resource.metadata.versioning || { enabled: false },
          server_side_encryption_configuration: resource.metadata.encryption || []
        };
      
      case 'AWS::ELB::LoadBalancer':
      case 'AWS::ElasticLoadBalancingV2::LoadBalancer':
        return {
          ...baseAttrs,
          load_balancer_type: resource.metadata.type || 'application',
          scheme: resource.metadata.scheme || 'internet-facing',
          security_groups: resource.metadata.securityGroups || [],
          subnets: resource.metadata.subnets || [],
          dns_name: resource.metadata.dnsName || `${resource.name}.us-east-1.elb.amazonaws.com`,
          zone_id: resource.metadata.canonicalHostedZoneId || 'Z35SXDOTRQ7X7K'
        };
      
      default:
        return baseAttrs;
    }
  }

  /**
   * Get S3 hosted zone ID by region
   */
  private getS3HostedZoneId(region: string): string {
    const hostedZoneIds: Record<string, string> = {
      'us-east-1': 'Z3AQBSTGFYJSTF',
      'us-east-2': 'Z2O1EMRO9K5GLX',
      'us-west-1': 'Z2F56UZL2M1ACD',
      'us-west-2': 'Z3BJ6K6RIION7M',
      'eu-west-1': 'Z1BKCTXD74EZPE',
      'eu-central-1': 'Z21DNDUVLTQW6Q',
      'ap-southeast-1': 'Z3O0SRN1WG5H81',
      'ap-northeast-1': 'Z2M4EHUR26P7ZW'
    };
    return hostedZoneIds[region] || 'Z3AQBSTGFYJSTF';
  }

  /**
   * Get AWS service name from resource type
   */
  private getServiceFromResourceType(resourceType: string): string {
    const serviceMap: Record<string, string> = {
      'AWS::EC2::Instance': 'ec2',
      'AWS::RDS::DBInstance': 'rds',
      'AWS::S3::Bucket': 's3',
      'AWS::ELB::LoadBalancer': 'elasticloadbalancing',
      'AWS::ElasticLoadBalancingV2::LoadBalancer': 'elasticloadbalancing'
    };
    return serviceMap[resourceType] || 'ec2';
  }
}